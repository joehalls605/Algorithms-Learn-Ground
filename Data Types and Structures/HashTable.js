/*
A hash table is a data structure that implements an associative array, mapping keys to values. 
It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be retrieved or stored. 
The key advantage of a hash table is its ability to provide constant-time average-case complexity for basic operations such as insertion, deletion, and lookup, 
making it highly efficient for many applications.

Here's how a hash table typically works:

Hash Function: A hash function takes a key as input and computes a hash code or hash value, which is a fixed-size representation of the key. The hash function should ideally produce unique hash values for distinct keys, but collisions (different keys mapping to the same hash value) can occur.
Hashing: The hash code generated by the hash function is used as an index into an array of buckets or slots in the hash table. Each bucket can store one or more key-value pairs.
Collision Resolution: In case of collisions, where multiple keys map to the same index, different techniques can be employed to resolve them. Common approaches include chaining (each bucket contains a linked list of key-value pairs) and open addressing (probing other locations in the table until an empty slot is found).
Operations:
Insertion: To insert a key-value pair, the key is hashed to determine the appropriate bucket in the hash table, and the pair is then stored in that bucket.
Deletion: To delete a key-value pair, the key is hashed to find the corresponding bucket, and the pair is removed from the bucket.
Lookup: To retrieve the value associated with a key, the key is hashed to determine the bucket, and the value is then retrieved from that bucket.
Hash tables are widely used in computer science and software engineering for implementing various data structures and algorithms, including associative arrays, sets, and caching mechanisms.
*/

// Hash function to generate a hash code for a given key
function hash(key, size) {
    let hashValue = 0;
    for (let i = 0; i < key.length; i++) {
        hashValue += key.charCodeAt(i);
    }
    return hashValue % size; // Modulo operation to ensure the hash code fits within the size of the hash table
}

// HashTable class
class HashTable {
    constructor(size = 10) {
        this.size = size;
        this.table = new Array(size).fill(null).map(() => []);
    }

    // Method to insert a key-value pair into the hash table
    insert(key, value) {
        const index = hash(key, this.size);
        this.table[index].push({ key, value });
    }

    // Method to retrieve the value associated with a given key
    get(key) {
        const index = hash(key, this.size);
        const bucket = this.table[index];
        for (const pair of bucket) {
            if (pair.key === key) {
                return pair.value;
            }
        }
        return undefined; // Key not found
    }

    // Method to remove a key-value pair from the hash table
    remove(key) {
        const index = hash(key, this.size);
        const bucket = this.table[index];
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key === key) {
                bucket.splice(i, 1); // Remove the pair from the bucket
                return;
            }
        }
    }
}

// Example usage
const myHashTable = new HashTable();
myHashTable.insert("apple", "red");
myHashTable.insert("banana", "yellow");
myHashTable.insert("grape", "purple");

console.log(myHashTable.get("apple")); // Output: "red"
console.log(myHashTable.get("banana")); // Output: "yellow"
console.log(myHashTable.get("grape")); // Output: "purple"

myHashTable.remove("banana");
console.log(myHashTable.get("banana")); // Output: undefined (removed)
